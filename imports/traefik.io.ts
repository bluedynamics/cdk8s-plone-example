// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * IngressRoute is the CRD implementation of a Traefik HTTP Router.
 *
 * @schema IngressRoute
 */
export class IngressRoute extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IngressRoute"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.io/v1alpha1',
    kind: 'IngressRoute',
  }

  /**
   * Renders a Kubernetes manifest for "IngressRoute".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IngressRouteProps): any {
    return {
      ...IngressRoute.GVK,
      ...toJson_IngressRouteProps(props),
    };
  }

  /**
   * Defines a "IngressRoute" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IngressRouteProps) {
    super(scope, id, {
      ...IngressRoute.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IngressRoute.GVK,
      ...toJson_IngressRouteProps(resolved),
    };
  }
}

/**
 * IngressRoute is the CRD implementation of a Traefik HTTP Router.
 *
 * @schema IngressRoute
 */
export interface IngressRouteProps {
  /**
   * @schema IngressRoute#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * IngressRouteSpec defines the desired state of IngressRoute.
   *
   * @schema IngressRoute#spec
   */
  readonly spec: IngressRouteSpec;

}

/**
 * Converts an object of type 'IngressRouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteProps(obj: IngressRouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IngressRouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressRouteSpec defines the desired state of IngressRoute.
 *
 * @schema IngressRouteSpec
 */
export interface IngressRouteSpec {
  /**
   * EntryPoints defines the list of entry point names to bind to.
   * Entry points have to be configured in the static configuration.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/entrypoints/
   * Default: all.
   *
   * @schema IngressRouteSpec#entryPoints
   */
  readonly entryPoints?: string[];

  /**
   * Routes defines the list of routes.
   *
   * @schema IngressRouteSpec#routes
   */
  readonly routes: IngressRouteSpecRoutes[];

  /**
   * TLS defines the TLS configuration.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/routers/#tls
   *
   * @schema IngressRouteSpec#tls
   */
  readonly tls?: IngressRouteSpecTls;

}

/**
 * Converts an object of type 'IngressRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpec(obj: IngressRouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entryPoints': obj.entryPoints?.map(y => y),
    'routes': obj.routes?.map(y => toJson_IngressRouteSpecRoutes(y)),
    'tls': toJson_IngressRouteSpecTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Route holds the HTTP route configuration.
 *
 * @schema IngressRouteSpecRoutes
 */
export interface IngressRouteSpecRoutes {
  /**
   * Kind defines the kind of the route.
   * Rule is the only supported kind.
   *
   * @schema IngressRouteSpecRoutes#kind
   */
  readonly kind: IngressRouteSpecRoutesKind;

  /**
   * Match defines the router's rule.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/routers/#rule
   *
   * @schema IngressRouteSpecRoutes#match
   */
  readonly match: string;

  /**
   * Middlewares defines the list of references to Middleware resources.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/providers/kubernetes-crd/#kind-middleware
   *
   * @schema IngressRouteSpecRoutes#middlewares
   */
  readonly middlewares?: IngressRouteSpecRoutesMiddlewares[];

  /**
   * Priority defines the router's priority.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/routers/#priority
   *
   * @schema IngressRouteSpecRoutes#priority
   */
  readonly priority?: number;

  /**
   * Services defines the list of Service.
   * It can contain any combination of TraefikService and/or reference to a Kubernetes Service.
   *
   * @schema IngressRouteSpecRoutes#services
   */
  readonly services?: IngressRouteSpecRoutesServices[];

  /**
   * Syntax defines the router's rule syntax.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/routers/#rulesyntax
   *
   * @schema IngressRouteSpecRoutes#syntax
   */
  readonly syntax?: string;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutes(obj: IngressRouteSpecRoutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'match': obj.match,
    'middlewares': obj.middlewares?.map(y => toJson_IngressRouteSpecRoutesMiddlewares(y)),
    'priority': obj.priority,
    'services': obj.services?.map(y => toJson_IngressRouteSpecRoutesServices(y)),
    'syntax': obj.syntax,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS defines the TLS configuration.
 * More info: https://doc.traefik.io/traefik/v3.1/routing/routers/#tls
 *
 * @schema IngressRouteSpecTls
 */
export interface IngressRouteSpecTls {
  /**
   * CertResolver defines the name of the certificate resolver to use.
   * Cert resolvers have to be configured in the static configuration.
   * More info: https://doc.traefik.io/traefik/v3.1/https/acme/#certificate-resolvers
   *
   * @schema IngressRouteSpecTls#certResolver
   */
  readonly certResolver?: string;

  /**
   * Domains defines the list of domains that will be used to issue certificates.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/routers/#domains
   *
   * @schema IngressRouteSpecTls#domains
   */
  readonly domains?: IngressRouteSpecTlsDomains[];

  /**
   * Options defines the reference to a TLSOption, that specifies the parameters of the TLS connection.
   * If not defined, the `default` TLSOption is used.
   * More info: https://doc.traefik.io/traefik/v3.1/https/tls/#tls-options
   *
   * @schema IngressRouteSpecTls#options
   */
  readonly options?: IngressRouteSpecTlsOptions;

  /**
   * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
   *
   * @schema IngressRouteSpecTls#secretName
   */
  readonly secretName?: string;

  /**
   * Store defines the reference to the TLSStore, that will be used to store certificates.
   * Please note that only `default` TLSStore can be used.
   *
   * @schema IngressRouteSpecTls#store
   */
  readonly store?: IngressRouteSpecTlsStore;

}

/**
 * Converts an object of type 'IngressRouteSpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecTls(obj: IngressRouteSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certResolver': obj.certResolver,
    'domains': obj.domains?.map(y => toJson_IngressRouteSpecTlsDomains(y)),
    'options': toJson_IngressRouteSpecTlsOptions(obj.options),
    'secretName': obj.secretName,
    'store': toJson_IngressRouteSpecTlsStore(obj.store),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind defines the kind of the route.
 * Rule is the only supported kind.
 *
 * @schema IngressRouteSpecRoutesKind
 */
export enum IngressRouteSpecRoutesKind {
  /** Rule */
  RULE = "Rule",
}

/**
 * MiddlewareRef is a reference to a Middleware resource.
 *
 * @schema IngressRouteSpecRoutesMiddlewares
 */
export interface IngressRouteSpecRoutesMiddlewares {
  /**
   * Name defines the name of the referenced Middleware resource.
   *
   * @schema IngressRouteSpecRoutesMiddlewares#name
   */
  readonly name: string;

  /**
   * Namespace defines the namespace of the referenced Middleware resource.
   *
   * @schema IngressRouteSpecRoutesMiddlewares#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutesMiddlewares' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutesMiddlewares(obj: IngressRouteSpecRoutesMiddlewares | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines an upstream HTTP service to proxy traffic to.
 *
 * @schema IngressRouteSpecRoutesServices
 */
export interface IngressRouteSpecRoutesServices {
  /**
   * Healthcheck defines health checks for ExternalName services.
   *
   * @schema IngressRouteSpecRoutesServices#healthCheck
   */
  readonly healthCheck?: IngressRouteSpecRoutesServicesHealthCheck;

  /**
   * Kind defines the kind of the Service.
   *
   * @schema IngressRouteSpecRoutesServices#kind
   */
  readonly kind?: IngressRouteSpecRoutesServicesKind;

  /**
   * Name defines the name of the referenced Kubernetes Service or TraefikService.
   * The differentiation between the two is specified in the Kind field.
   *
   * @schema IngressRouteSpecRoutesServices#name
   */
  readonly name: string;

  /**
   * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
   *
   * @schema IngressRouteSpecRoutesServices#namespace
   */
  readonly namespace?: string;

  /**
   * NativeLB controls, when creating the load-balancer,
   * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
   * The Kubernetes Service itself does load-balance to the pods.
   * By default, NativeLB is false.
   *
   * @schema IngressRouteSpecRoutesServices#nativeLB
   */
  readonly nativeLb?: boolean;

  /**
   * NodePortLB controls, when creating the load-balancer,
   * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
   * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
   * By default, NodePortLB is false.
   *
   * @schema IngressRouteSpecRoutesServices#nodePortLB
   */
  readonly nodePortLb?: boolean;

  /**
   * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
   * By default, passHostHeader is true.
   *
   * @schema IngressRouteSpecRoutesServices#passHostHeader
   */
  readonly passHostHeader?: boolean;

  /**
   * Port defines the port of a Kubernetes Service.
   * This can be a reference to a named port.
   *
   * @schema IngressRouteSpecRoutesServices#port
   */
  readonly port?: IngressRouteSpecRoutesServicesPort;

  /**
   * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
   *
   * @schema IngressRouteSpecRoutesServices#responseForwarding
   */
  readonly responseForwarding?: IngressRouteSpecRoutesServicesResponseForwarding;

  /**
   * Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
   * It defaults to https when Kubernetes Service port is 443, http otherwise.
   *
   * @schema IngressRouteSpecRoutesServices#scheme
   */
  readonly scheme?: string;

  /**
   * ServersTransport defines the name of ServersTransport resource to use.
   * It allows to configure the transport between Traefik and your servers.
   * Can only be used on a Kubernetes Service.
   *
   * @schema IngressRouteSpecRoutesServices#serversTransport
   */
  readonly serversTransport?: string;

  /**
   * Sticky defines the sticky sessions configuration.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/services/#sticky-sessions
   *
   * @schema IngressRouteSpecRoutesServices#sticky
   */
  readonly sticky?: IngressRouteSpecRoutesServicesSticky;

  /**
   * Strategy defines the load balancing strategy between the servers.
   * RoundRobin is the only supported value at the moment.
   *
   * @schema IngressRouteSpecRoutesServices#strategy
   */
  readonly strategy?: string;

  /**
   * Weight defines the weight and should only be specified when Name references a TraefikService object
   * (and to be precise, one that embeds a Weighted Round Robin).
   *
   * @schema IngressRouteSpecRoutesServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutesServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutesServices(obj: IngressRouteSpecRoutesServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheck': toJson_IngressRouteSpecRoutesServicesHealthCheck(obj.healthCheck),
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'nativeLB': obj.nativeLb,
    'nodePortLB': obj.nodePortLb,
    'passHostHeader': obj.passHostHeader,
    'port': obj.port?.value,
    'responseForwarding': toJson_IngressRouteSpecRoutesServicesResponseForwarding(obj.responseForwarding),
    'scheme': obj.scheme,
    'serversTransport': obj.serversTransport,
    'sticky': toJson_IngressRouteSpecRoutesServicesSticky(obj.sticky),
    'strategy': obj.strategy,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Domain holds a domain name with SANs.
 *
 * @schema IngressRouteSpecTlsDomains
 */
export interface IngressRouteSpecTlsDomains {
  /**
   * Main defines the main domain name.
   *
   * @schema IngressRouteSpecTlsDomains#main
   */
  readonly main?: string;

  /**
   * SANs defines the subject alternative domain names.
   *
   * @schema IngressRouteSpecTlsDomains#sans
   */
  readonly sans?: string[];

}

/**
 * Converts an object of type 'IngressRouteSpecTlsDomains' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecTlsDomains(obj: IngressRouteSpecTlsDomains | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'main': obj.main,
    'sans': obj.sans?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options defines the reference to a TLSOption, that specifies the parameters of the TLS connection.
 * If not defined, the `default` TLSOption is used.
 * More info: https://doc.traefik.io/traefik/v3.1/https/tls/#tls-options
 *
 * @schema IngressRouteSpecTlsOptions
 */
export interface IngressRouteSpecTlsOptions {
  /**
   * Name defines the name of the referenced TLSOption.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/providers/kubernetes-crd/#kind-tlsoption
   *
   * @schema IngressRouteSpecTlsOptions#name
   */
  readonly name: string;

  /**
   * Namespace defines the namespace of the referenced TLSOption.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/providers/kubernetes-crd/#kind-tlsoption
   *
   * @schema IngressRouteSpecTlsOptions#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'IngressRouteSpecTlsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecTlsOptions(obj: IngressRouteSpecTlsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Store defines the reference to the TLSStore, that will be used to store certificates.
 * Please note that only `default` TLSStore can be used.
 *
 * @schema IngressRouteSpecTlsStore
 */
export interface IngressRouteSpecTlsStore {
  /**
   * Name defines the name of the referenced TLSStore.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/providers/kubernetes-crd/#kind-tlsstore
   *
   * @schema IngressRouteSpecTlsStore#name
   */
  readonly name: string;

  /**
   * Namespace defines the namespace of the referenced TLSStore.
   * More info: https://doc.traefik.io/traefik/v3.1/routing/providers/kubernetes-crd/#kind-tlsstore
   *
   * @schema IngressRouteSpecTlsStore#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'IngressRouteSpecTlsStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecTlsStore(obj: IngressRouteSpecTlsStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Healthcheck defines health checks for ExternalName services.
 *
 * @schema IngressRouteSpecRoutesServicesHealthCheck
 */
export interface IngressRouteSpecRoutesServicesHealthCheck {
  /**
   * FollowRedirects defines whether redirects should be followed during the health check calls.
   * Default: true
   *
   * @schema IngressRouteSpecRoutesServicesHealthCheck#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * Headers defines custom headers to be sent to the health check endpoint.
   *
   * @schema IngressRouteSpecRoutesServicesHealthCheck#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Hostname defines the value of hostname in the Host header of the health check request.
   *
   * @schema IngressRouteSpecRoutesServicesHealthCheck#hostname
   */
  readonly hostname?: string;

  /**
   * Interval defines the frequency of the health check calls.
   * Default: 30s
   *
   * @schema IngressRouteSpecRoutesServicesHealthCheck#interval
   */
  readonly interval?: IngressRouteSpecRoutesServicesHealthCheckInterval;

  /**
   * Method defines the healthcheck method.
   *
   * @schema IngressRouteSpecRoutesServicesHealthCheck#method
   */
  readonly method?: string;

  /**
   * Mode defines the health check mode.
   * If defined to grpc, will use the gRPC health check protocol to probe the server.
   * Default: http
   *
   * @schema IngressRouteSpecRoutesServicesHealthCheck#mode
   */
  readonly mode?: string;

  /**
   * Path defines the server URL path for the health check endpoint.
   *
   * @schema IngressRouteSpecRoutesServicesHealthCheck#path
   */
  readonly path?: string;

  /**
   * Port defines the server URL port for the health check endpoint.
   *
   * @schema IngressRouteSpecRoutesServicesHealthCheck#port
   */
  readonly port?: number;

  /**
   * Scheme replaces the server URL scheme for the health check endpoint.
   *
   * @schema IngressRouteSpecRoutesServicesHealthCheck#scheme
   */
  readonly scheme?: string;

  /**
   * Status defines the expected HTTP status code of the response to the health check request.
   *
   * @schema IngressRouteSpecRoutesServicesHealthCheck#status
   */
  readonly status?: number;

  /**
   * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
   * Default: 5s
   *
   * @schema IngressRouteSpecRoutesServicesHealthCheck#timeout
   */
  readonly timeout?: IngressRouteSpecRoutesServicesHealthCheckTimeout;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutesServicesHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutesServicesHealthCheck(obj: IngressRouteSpecRoutesServicesHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'followRedirects': obj.followRedirects,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'hostname': obj.hostname,
    'interval': obj.interval?.value,
    'method': obj.method,
    'mode': obj.mode,
    'path': obj.path,
    'port': obj.port,
    'scheme': obj.scheme,
    'status': obj.status,
    'timeout': obj.timeout?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind defines the kind of the Service.
 *
 * @schema IngressRouteSpecRoutesServicesKind
 */
export enum IngressRouteSpecRoutesServicesKind {
  /** Service */
  SERVICE = "Service",
  /** TraefikService */
  TRAEFIK_SERVICE = "TraefikService",
}

/**
 * Port defines the port of a Kubernetes Service.
 * This can be a reference to a named port.
 *
 * @schema IngressRouteSpecRoutesServicesPort
 */
export class IngressRouteSpecRoutesServicesPort {
  public static fromNumber(value: number): IngressRouteSpecRoutesServicesPort {
    return new IngressRouteSpecRoutesServicesPort(value);
  }
  public static fromString(value: string): IngressRouteSpecRoutesServicesPort {
    return new IngressRouteSpecRoutesServicesPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
 *
 * @schema IngressRouteSpecRoutesServicesResponseForwarding
 */
export interface IngressRouteSpecRoutesServicesResponseForwarding {
  /**
   * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
   * A negative value means to flush immediately after each write to the client.
   * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
   * for such responses, writes are flushed to the client immediately.
   * Default: 100ms
   *
   * @schema IngressRouteSpecRoutesServicesResponseForwarding#flushInterval
   */
  readonly flushInterval?: string;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutesServicesResponseForwarding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutesServicesResponseForwarding(obj: IngressRouteSpecRoutesServicesResponseForwarding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flushInterval': obj.flushInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sticky defines the sticky sessions configuration.
 * More info: https://doc.traefik.io/traefik/v3.1/routing/services/#sticky-sessions
 *
 * @schema IngressRouteSpecRoutesServicesSticky
 */
export interface IngressRouteSpecRoutesServicesSticky {
  /**
   * Cookie defines the sticky cookie configuration.
   *
   * @schema IngressRouteSpecRoutesServicesSticky#cookie
   */
  readonly cookie?: IngressRouteSpecRoutesServicesStickyCookie;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutesServicesSticky' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutesServicesSticky(obj: IngressRouteSpecRoutesServicesSticky | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_IngressRouteSpecRoutesServicesStickyCookie(obj.cookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Interval defines the frequency of the health check calls.
 * Default: 30s
 *
 * @schema IngressRouteSpecRoutesServicesHealthCheckInterval
 */
export class IngressRouteSpecRoutesServicesHealthCheckInterval {
  public static fromNumber(value: number): IngressRouteSpecRoutesServicesHealthCheckInterval {
    return new IngressRouteSpecRoutesServicesHealthCheckInterval(value);
  }
  public static fromString(value: string): IngressRouteSpecRoutesServicesHealthCheckInterval {
    return new IngressRouteSpecRoutesServicesHealthCheckInterval(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
 * Default: 5s
 *
 * @schema IngressRouteSpecRoutesServicesHealthCheckTimeout
 */
export class IngressRouteSpecRoutesServicesHealthCheckTimeout {
  public static fromNumber(value: number): IngressRouteSpecRoutesServicesHealthCheckTimeout {
    return new IngressRouteSpecRoutesServicesHealthCheckTimeout(value);
  }
  public static fromString(value: string): IngressRouteSpecRoutesServicesHealthCheckTimeout {
    return new IngressRouteSpecRoutesServicesHealthCheckTimeout(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Cookie defines the sticky cookie configuration.
 *
 * @schema IngressRouteSpecRoutesServicesStickyCookie
 */
export interface IngressRouteSpecRoutesServicesStickyCookie {
  /**
   * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
   *
   * @schema IngressRouteSpecRoutesServicesStickyCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * MaxAge indicates the number of seconds until the cookie expires.
   * When set to a negative number, the cookie expires immediately.
   * When set to zero, the cookie never expires.
   *
   * @schema IngressRouteSpecRoutesServicesStickyCookie#maxAge
   */
  readonly maxAge?: number;

  /**
   * Name defines the Cookie name.
   *
   * @schema IngressRouteSpecRoutesServicesStickyCookie#name
   */
  readonly name?: string;

  /**
   * SameSite defines the same site policy.
   * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
   *
   * @schema IngressRouteSpecRoutesServicesStickyCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
   *
   * @schema IngressRouteSpecRoutesServicesStickyCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutesServicesStickyCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutesServicesStickyCookie(obj: IngressRouteSpecRoutesServicesStickyCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpOnly': obj.httpOnly,
    'maxAge': obj.maxAge,
    'name': obj.name,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

